Only in Swerve_Drive_Ely-2023/: .gitignore
Only in Swerve_Drive_Ely/.gradle: 7.3.3
Only in Swerve_Drive_Ely-2023/.gradle: 7.5.1
Binary files Swerve_Drive_Ely/.gradle/buildOutputCleanup/buildOutputCleanup.lock and Swerve_Drive_Ely-2023/.gradle/buildOutputCleanup/buildOutputCleanup.lock differ
diff -r Swerve_Drive_Ely/.gradle/buildOutputCleanup/cache.properties Swerve_Drive_Ely-2023/.gradle/buildOutputCleanup/cache.properties
1,2c1,2
< #Sat Feb 04 09:29:28 EST 2023
< gradle.version=7.3.3
---
> #Sat Feb 04 09:31:14 EST 2023
> gradle.version=7.5.1
Only in Swerve_Drive_Ely-2023/.gradle/buildOutputCleanup: outputFiles.bin
Only in Swerve_Drive_Ely-2023/.gradle: file-system.probe
diff -r Swerve_Drive_Ely/.wpilib/wpilib_preferences.json Swerve_Drive_Ely-2023/.wpilib/wpilib_preferences.json
1,5c1,5
< {
<     "enableCppIntellisense": false,
<     "currentLanguage": "java",
<     "projectYear": "2022",
<     "teamNumber": 3414
---
> {
>     "enableCppIntellisense": false,
>     "currentLanguage": "java",
>     "projectYear": "2023",
>     "teamNumber": 3414
Binary files Swerve_Drive_Ely/bin/main/frc/robot/Constants.class and Swerve_Drive_Ely-2023/bin/main/frc/robot/Constants.class differ
Binary files Swerve_Drive_Ely/bin/main/frc/robot/subsystems/SwerveModule.class and Swerve_Drive_Ely-2023/bin/main/frc/robot/subsystems/SwerveModule.class differ
Binary files Swerve_Drive_Ely/bin/main/frc/robot/subsystems/SwerveSubsystem.class and Swerve_Drive_Ely-2023/bin/main/frc/robot/subsystems/SwerveSubsystem.class differ
Only in Swerve_Drive_Ely-2023/: build
diff -r Swerve_Drive_Ely/build.gradle Swerve_Drive_Ely-2023/build.gradle
3c3
<     id "edu.wpi.first.GradleRIO" version "2022.4.1"
---
>     id "edu.wpi.first.GradleRIO" version "2023.3.2"
49c49
< // Also defines JUnit 4.
---
> // Also defines JUnit 5.
68c68,75
<     testImplementation 'junit:junit:4.13.1'
---
>     testImplementation 'org.junit.jupiter:junit-jupiter-api:5.8.2'
>     testImplementation 'org.junit.jupiter:junit-jupiter-params:5.8.2'
>     testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.8.2'
> }
> 
> test {
>     useJUnitPlatform()
>     systemProperty 'junit.jupiter.extensions.autodetection.enabled', 'true'
87a95,99
> 
> // Configure string concat to always inline compile
> tasks.withType(JavaCompile) {
>     options.compilerArgs.add '-XDstringConcat=inline'
> }
Binary files Swerve_Drive_Ely/gradle/wrapper/gradle-wrapper.jar and Swerve_Drive_Ely-2023/gradle/wrapper/gradle-wrapper.jar differ
diff -r Swerve_Drive_Ely/gradle/wrapper/gradle-wrapper.properties Swerve_Drive_Ely-2023/gradle/wrapper/gradle-wrapper.properties
3c3
< distributionUrl=https\://services.gradle.org/distributions/gradle-7.3.3-bin.zip
---
> distributionUrl=https\://services.gradle.org/distributions/gradle-7.5.1-bin.zip
diff -r Swerve_Drive_Ely/gradlew Swerve_Drive_Ely-2023/gradlew
1,234c1,240
< #!/bin/sh
< 
< #
< # Copyright © 2015-2021 the original authors.
< #
< # Licensed under the Apache License, Version 2.0 (the "License");
< # you may not use this file except in compliance with the License.
< # You may obtain a copy of the License at
< #
< #      https://www.apache.org/licenses/LICENSE-2.0
< #
< # Unless required by applicable law or agreed to in writing, software
< # distributed under the License is distributed on an "AS IS" BASIS,
< # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< # See the License for the specific language governing permissions and
< # limitations under the License.
< #
< 
< ##############################################################################
< #
< #   Gradle start up script for POSIX generated by Gradle.
< #
< #   Important for running:
< #
< #   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
< #       noncompliant, but you have some other compliant shell such as ksh or
< #       bash, then to run this script, type that shell name before the whole
< #       command line, like:
< #
< #           ksh Gradle
< #
< #       Busybox and similar reduced shells will NOT work, because this script
< #       requires all of these POSIX shell features:
< #         * functions;
< #         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
< #           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
< #         * compound commands having a testable exit status, especially «case»;
< #         * various built-in commands including «command», «set», and «ulimit».
< #
< #   Important for patching:
< #
< #   (2) This script targets any POSIX shell, so it avoids extensions provided
< #       by Bash, Ksh, etc; in particular arrays are avoided.
< #
< #       The "traditional" practice of packing multiple parameters into a
< #       space-separated string is a well documented source of bugs and security
< #       problems, so this is (mostly) avoided, by progressively accumulating
< #       options in "$@", and eventually passing that to Java.
< #
< #       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
< #       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
< #       see the in-line comments for details.
< #
< #       There are tweaks for specific operating systems such as AIX, CygWin,
< #       Darwin, MinGW, and NonStop.
< #
< #   (3) This script is generated from the Groovy template
< #       https://github.com/gradle/gradle/blob/master/subprojects/plugins/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
< #       within the Gradle project.
< #
< #       You can find Gradle at https://github.com/gradle/gradle/.
< #
< ##############################################################################
< 
< # Attempt to set APP_HOME
< 
< # Resolve links: $0 may be a link
< app_path=$0
< 
< # Need this for daisy-chained symlinks.
< while
<     APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
<     [ -h "$app_path" ]
< do
<     ls=$( ls -ld "$app_path" )
<     link=${ls#*' -> '}
<     case $link in             #(
<       /*)   app_path=$link ;; #(
<       *)    app_path=$APP_HOME$link ;;
<     esac
< done
< 
< APP_HOME=$( cd "${APP_HOME:-./}" && pwd -P ) || exit
< 
< APP_NAME="Gradle"
< APP_BASE_NAME=${0##*/}
< 
< # Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
< DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'
< 
< # Use the maximum available, or set MAX_FD != -1 to use that value.
< MAX_FD=maximum
< 
< warn () {
<     echo "$*"
< } >&2
< 
< die () {
<     echo
<     echo "$*"
<     echo
<     exit 1
< } >&2
< 
< # OS specific support (must be 'true' or 'false').
< cygwin=false
< msys=false
< darwin=false
< nonstop=false
< case "$( uname )" in                #(
<   CYGWIN* )         cygwin=true  ;; #(
<   Darwin* )         darwin=true  ;; #(
<   MSYS* | MINGW* )  msys=true    ;; #(
<   NONSTOP* )        nonstop=true ;;
< esac
< 
< CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
< 
< 
< # Determine the Java command to use to start the JVM.
< if [ -n "$JAVA_HOME" ] ; then
<     if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
<         # IBM's JDK on AIX uses strange locations for the executables
<         JAVACMD=$JAVA_HOME/jre/sh/java
<     else
<         JAVACMD=$JAVA_HOME/bin/java
<     fi
<     if [ ! -x "$JAVACMD" ] ; then
<         die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
< 
< Please set the JAVA_HOME variable in your environment to match the
< location of your Java installation."
<     fi
< else
<     JAVACMD=java
<     which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
< 
< Please set the JAVA_HOME variable in your environment to match the
< location of your Java installation."
< fi
< 
< # Increase the maximum file descriptors if we can.
< if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
<     case $MAX_FD in #(
<       max*)
<         MAX_FD=$( ulimit -H -n ) ||
<             warn "Could not query maximum file descriptor limit"
<     esac
<     case $MAX_FD in  #(
<       '' | soft) :;; #(
<       *)
<         ulimit -n "$MAX_FD" ||
<             warn "Could not set maximum file descriptor limit to $MAX_FD"
<     esac
< fi
< 
< # Collect all arguments for the java command, stacking in reverse order:
< #   * args from the command line
< #   * the main class name
< #   * -classpath
< #   * -D...appname settings
< #   * --module-path (only if needed)
< #   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.
< 
< # For Cygwin or MSYS, switch paths to Windows format before running java
< if "$cygwin" || "$msys" ; then
<     APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
<     CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )
< 
<     JAVACMD=$( cygpath --unix "$JAVACMD" )
< 
<     # Now convert the arguments - kludge to limit ourselves to /bin/sh
<     for arg do
<         if
<             case $arg in                                #(
<               -*)   false ;;                            # don't mess with options #(
<               /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
<                     [ -e "$t" ] ;;                      #(
<               *)    false ;;
<             esac
<         then
<             arg=$( cygpath --path --ignore --mixed "$arg" )
<         fi
<         # Roll the args list around exactly as many times as the number of
<         # args, so each arg winds up back in the position where it started, but
<         # possibly modified.
<         #
<         # NB: a `for` loop captures its iteration list before it begins, so
<         # changing the positional parameters here affects neither the number of
<         # iterations, nor the values presented in `arg`.
<         shift                   # remove old arg
<         set -- "$@" "$arg"      # push replacement arg
<     done
< fi
< 
< # Collect all arguments for the java command;
< #   * $DEFAULT_JVM_OPTS, $JAVA_OPTS, and $GRADLE_OPTS can contain fragments of
< #     shell script including quotes and variable substitutions, so put them in
< #     double quotes to make sure that they get re-expanded; and
< #   * put everything else in single quotes, so that it's not re-expanded.
< 
< set -- \
<         "-Dorg.gradle.appname=$APP_BASE_NAME" \
<         -classpath "$CLASSPATH" \
<         org.gradle.wrapper.GradleWrapperMain \
<         "$@"
< 
< # Use "xargs" to parse quoted args.
< #
< # With -n1 it outputs one arg per line, with the quotes and backslashes removed.
< #
< # In Bash we could simply go:
< #
< #   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
< #   set -- "${ARGS[@]}" "$@"
< #
< # but POSIX shell has neither arrays nor command substitution, so instead we
< # post-process each arg (as a line of input to sed) to backslash-escape any
< # character that might be a shell metacharacter, then use eval to reverse
< # that process (while maintaining the separation between arguments), and wrap
< # the whole thing up as a single "set" statement.
< #
< # This will of course break if any of these variables contains a newline or
< # an unmatched quote.
< #
< 
< eval "set -- $(
<         printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
<         xargs -n1 |
<         sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
<         tr '\n' ' '
<     )" '"$@"'
< 
< exec "$JAVACMD" "$@"
---
> #!/bin/sh
> 
> #
> # Copyright Â© 2015-2021 the original authors.
> #
> # Licensed under the Apache License, Version 2.0 (the "License");
> # you may not use this file except in compliance with the License.
> # You may obtain a copy of the License at
> #
> #      https://www.apache.org/licenses/LICENSE-2.0
> #
> # Unless required by applicable law or agreed to in writing, software
> # distributed under the License is distributed on an "AS IS" BASIS,
> # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
> # See the License for the specific language governing permissions and
> # limitations under the License.
> #
> 
> ##############################################################################
> #
> #   Gradle start up script for POSIX generated by Gradle.
> #
> #   Important for running:
> #
> #   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
> #       noncompliant, but you have some other compliant shell such as ksh or
> #       bash, then to run this script, type that shell name before the whole
> #       command line, like:
> #
> #           ksh Gradle
> #
> #       Busybox and similar reduced shells will NOT work, because this script
> #       requires all of these POSIX shell features:
> #         * functions;
> #         * expansions Â«$varÂ», Â«${var}Â», Â«${var:-default}Â», Â«${var+SET}Â»,
> #           Â«${var#prefix}Â», Â«${var%suffix}Â», and Â«$( cmd )Â»;
> #         * compound commands having a testable exit status, especially Â«caseÂ»;
> #         * various built-in commands including Â«commandÂ», Â«setÂ», and Â«ulimitÂ».
> #
> #   Important for patching:
> #
> #   (2) This script targets any POSIX shell, so it avoids extensions provided
> #       by Bash, Ksh, etc; in particular arrays are avoided.
> #
> #       The "traditional" practice of packing multiple parameters into a
> #       space-separated string is a well documented source of bugs and security
> #       problems, so this is (mostly) avoided, by progressively accumulating
> #       options in "$@", and eventually passing that to Java.
> #
> #       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
> #       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
> #       see the in-line comments for details.
> #
> #       There are tweaks for specific operating systems such as AIX, CygWin,
> #       Darwin, MinGW, and NonStop.
> #
> #   (3) This script is generated from the Groovy template
> #       https://github.com/gradle/gradle/blob/master/subprojects/plugins/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
> #       within the Gradle project.
> #
> #       You can find Gradle at https://github.com/gradle/gradle/.
> #
> ##############################################################################
> 
> # Attempt to set APP_HOME
> 
> # Resolve links: $0 may be a link
> app_path=$0
> 
> # Need this for daisy-chained symlinks.
> while
>     APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
>     [ -h "$app_path" ]
> do
>     ls=$( ls -ld "$app_path" )
>     link=${ls#*' -> '}
>     case $link in             #(
>       /*)   app_path=$link ;; #(
>       *)    app_path=$APP_HOME$link ;;
>     esac
> done
> 
> APP_HOME=$( cd "${APP_HOME:-./}" && pwd -P ) || exit
> 
> APP_NAME="Gradle"
> APP_BASE_NAME=${0##*/}
> 
> # Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
> DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'
> 
> # Use the maximum available, or set MAX_FD != -1 to use that value.
> MAX_FD=maximum
> 
> warn () {
>     echo "$*"
> } >&2
> 
> die () {
>     echo
>     echo "$*"
>     echo
>     exit 1
> } >&2
> 
> # OS specific support (must be 'true' or 'false').
> cygwin=false
> msys=false
> darwin=false
> nonstop=false
> case "$( uname )" in                #(
>   CYGWIN* )         cygwin=true  ;; #(
>   Darwin* )         darwin=true  ;; #(
>   MSYS* | MINGW* )  msys=true    ;; #(
>   NONSTOP* )        nonstop=true ;;
> esac
> 
> CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
> 
> 
> # Determine the Java command to use to start the JVM.
> if [ -n "$JAVA_HOME" ] ; then
>     if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
>         # IBM's JDK on AIX uses strange locations for the executables
>         JAVACMD=$JAVA_HOME/jre/sh/java
>     else
>         JAVACMD=$JAVA_HOME/bin/java
>     fi
>     if [ ! -x "$JAVACMD" ] ; then
>         die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
> 
> Please set the JAVA_HOME variable in your environment to match the
> location of your Java installation."
>     fi
> else
>     JAVACMD=java
>     which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
> 
> Please set the JAVA_HOME variable in your environment to match the
> location of your Java installation."
> fi
> 
> # Increase the maximum file descriptors if we can.
> if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
>     case $MAX_FD in #(
>       max*)
>         MAX_FD=$( ulimit -H -n ) ||
>             warn "Could not query maximum file descriptor limit"
>     esac
>     case $MAX_FD in  #(
>       '' | soft) :;; #(
>       *)
>         ulimit -n "$MAX_FD" ||
>             warn "Could not set maximum file descriptor limit to $MAX_FD"
>     esac
> fi
> 
> # Collect all arguments for the java command, stacking in reverse order:
> #   * args from the command line
> #   * the main class name
> #   * -classpath
> #   * -D...appname settings
> #   * --module-path (only if needed)
> #   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.
> 
> # For Cygwin or MSYS, switch paths to Windows format before running java
> if "$cygwin" || "$msys" ; then
>     APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
>     CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )
> 
>     JAVACMD=$( cygpath --unix "$JAVACMD" )
> 
>     # Now convert the arguments - kludge to limit ourselves to /bin/sh
>     for arg do
>         if
>             case $arg in                                #(
>               -*)   false ;;                            # don't mess with options #(
>               /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
>                     [ -e "$t" ] ;;                      #(
>               *)    false ;;
>             esac
>         then
>             arg=$( cygpath --path --ignore --mixed "$arg" )
>         fi
>         # Roll the args list around exactly as many times as the number of
>         # args, so each arg winds up back in the position where it started, but
>         # possibly modified.
>         #
>         # NB: a `for` loop captures its iteration list before it begins, so
>         # changing the positional parameters here affects neither the number of
>         # iterations, nor the values presented in `arg`.
>         shift                   # remove old arg
>         set -- "$@" "$arg"      # push replacement arg
>     done
> fi
> 
> # Collect all arguments for the java command;
> #   * $DEFAULT_JVM_OPTS, $JAVA_OPTS, and $GRADLE_OPTS can contain fragments of
> #     shell script including quotes and variable substitutions, so put them in
> #     double quotes to make sure that they get re-expanded; and
> #   * put everything else in single quotes, so that it's not re-expanded.
> 
> set -- \
>         "-Dorg.gradle.appname=$APP_BASE_NAME" \
>         -classpath "$CLASSPATH" \
>         org.gradle.wrapper.GradleWrapperMain \
>         "$@"
> 
> # Stop when "xargs" is not available.
> if ! command -v xargs >/dev/null 2>&1
> then
>     die "xargs is not available"
> fi
> 
> # Use "xargs" to parse quoted args.
> #
> # With -n1 it outputs one arg per line, with the quotes and backslashes removed.
> #
> # In Bash we could simply go:
> #
> #   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
> #   set -- "${ARGS[@]}" "$@"
> #
> # but POSIX shell has neither arrays nor command substitution, so instead we
> # post-process each arg (as a line of input to sed) to backslash-escape any
> # character that might be a shell metacharacter, then use eval to reverse
> # that process (while maintaining the separation between arguments), and wrap
> # the whole thing up as a single "set" statement.
> #
> # This will of course break if any of these variables contains a newline or
> # an unmatched quote.
> #
> 
> eval "set -- $(
>         printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
>         xargs -n1 |
>         sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
>         tr '\n' ' '
>     )" '"$@"'
> 
> exec "$JAVACMD" "$@"
diff -r Swerve_Drive_Ely/gradlew.bat Swerve_Drive_Ely-2023/gradlew.bat
17c17
< @if "%DEBUG%" == "" @echo off
---
> @if "%DEBUG%"=="" @echo off
28c28
< if "%DIRNAME%" == "" set DIRNAME=.
---
> if "%DIRNAME%"=="" set DIRNAME=.
43c43
< if "%ERRORLEVEL%" == "0" goto execute
---
> if %ERRORLEVEL% equ 0 goto execute
78c78
< if "%ERRORLEVEL%"=="0" goto mainEnd
---
> if %ERRORLEVEL% equ 0 goto mainEnd
83,84c83,86
< if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
< exit /b 1
---
> set EXIT_CODE=%ERRORLEVEL%
> if %EXIT_CODE% equ 0 set EXIT_CODE=1
> if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
> exit /b %EXIT_CODE%
diff -r Swerve_Drive_Ely/settings.gradle Swerve_Drive_Ely-2023/settings.gradle
7c7
<         String frcYear = '2022'
---
>         String frcYear = '2023'
diff -r Swerve_Drive_Ely/src/main/java/frc/robot/Constants.java Swerve_Drive_Ely-2023/src/main/java/frc/robot/Constants.java
16c16
<     public static String kCanivoreName = "falcons-canivore";
---
>     public static String kCanivoreName = "rio";//"falcons-canivore";
diff -r Swerve_Drive_Ely/src/main/java/frc/robot/subsystems/SwerveModule.java Swerve_Drive_Ely-2023/src/main/java/frc/robot/subsystems/SwerveModule.java
10a11
> import edu.wpi.first.math.kinematics.SwerveModulePosition;
11a13
> 
55a58,67
> //Return MotorID
>     public int getDriveMotorID(){
>         return driveTalon.getDeviceID();
>     }
>     
>     public SwerveModulePosition getPosition() {
>         double distance = driveTalon.getSelectedSensorPosition() * Constants.ModuleConstants.kDriveEncoderMeterPerTick;
>         Rotation2d angle = Rotation2d.fromDegrees( azimuthTalon.getSelectedSensorPosition() * (360.0 / (Constants.ModuleConstants.kAzimuthEncoderGearRatio * 2048.0)));
>         return new SwerveModulePosition(distance, angle);
>     }
diff -r Swerve_Drive_Ely/src/main/java/frc/robot/subsystems/SwerveSubsystem.java Swerve_Drive_Ely-2023/src/main/java/frc/robot/subsystems/SwerveSubsystem.java
8a9
> import edu.wpi.first.math.kinematics.SwerveModulePosition;
16,54c17,61
<     private final SwerveModule frontLeft = new SwerveModule(
<             DriveConstants.kFrontLeftDriveMotorPort,
<             DriveConstants.kFrontLeftAzimuthMotorPort,
<             DriveConstants.kFrontLeftDriveEncoderReversed,
<             DriveConstants.kFrontLeftAzimuthEncoderReversed,
<             DriveConstants.kFrontLeftDriveAbsoluteEncoderOffsetRad,
<             DriveConstants.kFrontLeftDriveAbsoluteEncoderReversed,
<             ModuleConstants.azimuthConfig,
<             ModuleConstants.driveConfig);
< 
<     private final SwerveModule frontRight = new SwerveModule(
<             DriveConstants.kFrontRightDriveMotorPort,
<             DriveConstants.kFrontRightAzimuthMotorPort,
<             DriveConstants.kFrontRightDriveEncoderReversed,
<             DriveConstants.kFrontRightAzimuthEncoderReversed,
<             DriveConstants.kFrontRightDriveAbsoluteEncoderOffsetRad,
<             DriveConstants.kFrontRightDriveAbsoluteEncoderReversed,
<             ModuleConstants.azimuthConfig,
<             ModuleConstants.driveConfig);
< 
<     private final SwerveModule backLeft = new SwerveModule(
<             DriveConstants.kBackLeftDriveMotorPort,
<             DriveConstants.kBackLeftAzimuthMotorPort,
<             DriveConstants.kBackLeftDriveEncoderReversed,
<             DriveConstants.kBackLeftAzimuthEncoderReversed,
<             DriveConstants.kBackLeftDriveAbsoluteEncoderOffsetRad,
<             DriveConstants.kBackLeftDriveAbsoluteEncoderReversed,
<             ModuleConstants.azimuthConfig,
<             ModuleConstants.driveConfig);
< 
<     private final SwerveModule backRight = new SwerveModule(
<             DriveConstants.kBackRightDriveMotorPort,
<             DriveConstants.kBackRightAzimuthMotorPort,
<             DriveConstants.kBackRightDriveEncoderReversed,
<             DriveConstants.kBackRightAzimuthEncoderReversed,
<             DriveConstants.kBackRightDriveAbsoluteEncoderOffsetRad,
<             DriveConstants.kBackRightDriveAbsoluteEncoderReversed,
<             ModuleConstants.azimuthConfig,
<             ModuleConstants.driveConfig);
---
> 
>     SwerveModule[] mSwerveMods = {
>             new SwerveModule(
>                     DriveConstants.kFrontLeftDriveMotorPort,
>                     DriveConstants.kFrontLeftAzimuthMotorPort,
>                     DriveConstants.kFrontLeftDriveEncoderReversed,
>                     DriveConstants.kFrontLeftAzimuthEncoderReversed,
>                     DriveConstants.kFrontLeftDriveAbsoluteEncoderOffsetRad,
>                     DriveConstants.kFrontLeftDriveAbsoluteEncoderReversed,
>                     ModuleConstants.azimuthConfig,
>                     ModuleConstants.driveConfig),
>             new SwerveModule(
>                     DriveConstants.kFrontRightDriveMotorPort,
>                     DriveConstants.kFrontRightAzimuthMotorPort,
>                     DriveConstants.kFrontRightDriveEncoderReversed,
>                     DriveConstants.kFrontRightAzimuthEncoderReversed,
>                     DriveConstants.kFrontRightDriveAbsoluteEncoderOffsetRad,
>                     DriveConstants.kFrontRightDriveAbsoluteEncoderReversed,
>                     ModuleConstants.azimuthConfig,
>                     ModuleConstants.driveConfig),
>             new SwerveModule(
>                     DriveConstants.kBackLeftDriveMotorPort,
>                     DriveConstants.kBackLeftAzimuthMotorPort,
>                     DriveConstants.kBackLeftDriveEncoderReversed,
>                     DriveConstants.kBackLeftAzimuthEncoderReversed,
>                     DriveConstants.kBackLeftDriveAbsoluteEncoderOffsetRad,
>                     DriveConstants.kBackLeftDriveAbsoluteEncoderReversed,
>                     ModuleConstants.azimuthConfig,
>                     ModuleConstants.driveConfig),
>             new SwerveModule(
>                     DriveConstants.kBackRightDriveMotorPort,
>                     DriveConstants.kBackRightAzimuthMotorPort,
>                     DriveConstants.kBackRightDriveEncoderReversed,
>                     DriveConstants.kBackRightAzimuthEncoderReversed,
>                     DriveConstants.kBackRightDriveAbsoluteEncoderOffsetRad,
>                     DriveConstants.kBackRightDriveAbsoluteEncoderReversed,
>                     ModuleConstants.azimuthConfig,
>                     ModuleConstants.driveConfig) };
> 
>     SwerveModulePosition[] mPositions = {
>         new SwerveModulePosition(),
>         new SwerveModulePosition(),
>         new SwerveModulePosition(),
>         new SwerveModulePosition()
>     };
57,58c64
<     private final SwerveDriveOdometry odometer = new SwerveDriveOdometry(DriveConstants.kDriveKinematics,
<             new Rotation2d(0));
---
>     private final SwerveDriveOdometry odometer;
67a74,76
> 
>         odometer = new SwerveDriveOdometry(DriveConstants.kDriveKinematics,
>             new Rotation2d(0), getPositions() );
73a83,91
>     public SwerveModulePosition[] getPositions() {
>         // SwerveModulePosition[] positions = new SwerveModulePosition[4];
>         mPositions[0] = mSwerveMods[0].getPosition();
>         mPositions[1] = mSwerveMods[1].getPosition();
>         mPositions[2] = mSwerveMods[2].getPosition();
>         mPositions[3] = mSwerveMods[3].getPosition();
>         return mPositions;
>     }
> 
87c105
<         odometer.resetPosition(pose, getRotation2d());
---
>         odometer.resetPosition(getRotation2d(), getPositions(), pose);
92,94c110,111
<         odometer.update(getRotation2d(), frontLeft.getState(), frontRight.getState(), backLeft.getState(),
<                 backRight.getState());
< //Robot State
---
>         odometer.update(getRotation2d(), getPositions());
>         // Robot State
97,107c114,124
< //Module Absolute Angle Raw
<         SmartDashboard.putNumber("Front Left Azimuth Absolute", frontLeft.getAbsoluteEncoderRadRaw());
<         SmartDashboard.putNumber("Front Right Azimuth Absolute", frontRight.getAbsoluteEncoderRadRaw());
<         SmartDashboard.putNumber("Back Left Azimuth Absolute", backLeft.getAbsoluteEncoderRadRaw());
<         SmartDashboard.putNumber("Back Right Azimuth Absolute", backRight.getAbsoluteEncoderRadRaw());
< //Module Angle
<         SmartDashboard.putNumber("Front Left Azimuth", frontLeft.getAzimuthPosition());
<         SmartDashboard.putNumber("Front Right Azimuth", frontRight.getAzimuthPosition());
<         SmartDashboard.putNumber("Back Left Azimuth", backLeft.getAzimuthPosition());
<         SmartDashboard.putNumber("Back Right Azimuth", backRight.getAzimuthPosition());
< //Gyro Angle
---
>         // Module Absolute Angle Raw
>         SmartDashboard.putNumber("Front Left Azimuth Absolute", mSwerveMods[0].getAbsoluteEncoderRadRaw());
>         SmartDashboard.putNumber("Front Right Azimuth Absolute", mSwerveMods[1].getAbsoluteEncoderRadRaw());
>         SmartDashboard.putNumber("Back Left Azimuth Absolute", mSwerveMods[2].getAbsoluteEncoderRadRaw());
>         SmartDashboard.putNumber("Back Right Azimuth Absolute", mSwerveMods[3].getAbsoluteEncoderRadRaw());
>         // Module Angle
>         SmartDashboard.putNumber("Front Left Azimuth", mSwerveMods[0].getAzimuthPosition());
>         SmartDashboard.putNumber("Front Right Azimuth", mSwerveMods[1].getAzimuthPosition());
>         SmartDashboard.putNumber("Back Left Azimuth", mSwerveMods[2].getAzimuthPosition());
>         SmartDashboard.putNumber("Back Right Azimuth", mSwerveMods[3].getAzimuthPosition());
>         // Gyro Angle
109,113c126,130
< //Wheel Speed
<         SmartDashboard.putNumber("Front Left Drive m/s", frontLeft.getDriveVelocity());
<         SmartDashboard.putNumber("Front Right Drive m/s", frontRight.getDriveVelocity());
<         SmartDashboard.putNumber("Back Left Drive m/s", backLeft.getDriveVelocity());
<         SmartDashboard.putNumber("Back Right Drive m/s", backRight.getDriveVelocity());
---
>         // Wheel Speed
>         SmartDashboard.putNumber("Front Left Drive m/s", mSwerveMods[0].getDriveVelocity());
>         SmartDashboard.putNumber("Front Right Drive m/s", mSwerveMods[1].getDriveVelocity());
>         SmartDashboard.putNumber("Back Left Drive m/s", mSwerveMods[2].getDriveVelocity());
>         SmartDashboard.putNumber("Back Right Drive m/s", mSwerveMods[3].getDriveVelocity());
117,120c134,137
<         frontLeft.stop();
<         frontRight.stop();
<         backLeft.stop();
<         backRight.stop();
---
>         mSwerveMods[0].stop();
>         mSwerveMods[1].stop();
>         mSwerveMods[2].stop();
>         mSwerveMods[3].stop();
125,129c142,147
<         frontLeft.setDesiredState(desiredStates[0]);
<         frontRight.setDesiredState(desiredStates[1]);
<         backLeft.setDesiredState(desiredStates[2]);
<         backRight.setDesiredState(desiredStates[3]);
<         //SmartDashboard.putString("Back Right Desired Angle", desiredStates[3].angle.toString());
---
>         mSwerveMods[0].setDesiredState(desiredStates[0]);
>         mSwerveMods[1].setDesiredState(desiredStates[1]);
>         mSwerveMods[2].setDesiredState(desiredStates[2]);
>         mSwerveMods[3].setDesiredState(desiredStates[3]);
>         // SmartDashboard.putString("Back Right Desired Angle",
>         // desiredStates[3].angle.toString());
Only in Swerve_Drive_Ely-2023/vendordeps: NavX.json
Only in Swerve_Drive_Ely/vendordeps: PathplannerLib.json
Only in Swerve_Drive_Ely-2023/vendordeps: Phoenix.json
diff -r Swerve_Drive_Ely/vendordeps/WPILibNewCommands.json Swerve_Drive_Ely-2023/vendordeps/WPILibNewCommands.json
28,29c28,29
<               "linuxraspbian",
<               "linuxaarch64bionic",
---
>               "linuxarm32",
>               "linuxarm64",
33c33
<               "osxx86-64"
---
>               "osxuniversal"
Only in Swerve_Drive_Ely/vendordeps: navx_frc.json
Only in Swerve_Drive_Ely/vendordeps: phoenix.json
